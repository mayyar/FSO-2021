## **a. Introduction to React**

The easiest way to get started by far is by using a tool called create-react-app.

```
$ npx create-react-app part1
$ cd part1
$ npm start
```

By default, the application runs in localhost port 3000 with the address http://localhost:3000

## Component

The file *App.js* now defines a React component with the name *App*.

There are a few ways to define functions in JavaScript. Here we will use arrow functions, which are described in a newer version of JavaScript known as ECMAScript 6, also called ES6.

```javascript
const App = () => {
  return (
    <div>
      <p>Hello world</p>
    </div>
  )
}
```

## JSX

The layout of React components is mostly written using JSX. Although JSX looks like HTML, we are actually dealing with a way to write JavaScript. Under the hood, JSX returned by React components is compiled into JavaScript.

JSX is "XML-like", which means that every tag needs to be closed. 

## Multiple components

```javascript
const Hello = () => {
  return (
    <div>
      <p>Hello world</p>
    </div>
  )
}

const App = () => {
  return (
    <div>
      <h1>Greetings</h1>
      <Hello />
    </div>
  )
}
```

## props: passing data to components

It is possible to pass data to components using so called props.

```javascript
const Hello = (props) => {
  return (
    <div>
      <p>Hello {props.name}</p>
    </div>
  )
}

const App = () => {
  return (
    <div>
      <h1>Greetings</h1>
      <Hello name="George" />
      <Hello name="Daisy" />
    </div>
  )
}
```

There can be an arbitrary number of props and their values can be "hard coded" strings or results of JavaScript expressions. If the value of the prop is achieved using JavaScript it must be wrapped with curly braces.

## Some notes

Also keep in mind that **React component names must be capitalized**. 
Note that the content of a React component (usually) needs to contain **one root element**.
An array of components is also a valid solution:

```javascript
const App = () => {
  return [
    <h1>Greetings</h1>,
    <Hello name="Maya" age={26 + 10} />,
    <Footer />
  ]
}
```

Because the root element is stipulated, we have "extra" div-elements in the DOM-tree. This can be avoided by using fragments, i.e. by wrapping the elements to be returned by the component with an empty element:

```javascript
const App = () => {
  const name = 'Peter'
  const age = 10

  return (
    <>
      <h1>Greetings</h1>
      <Hello name="Maya" age={26 + 10} />
      <Hello name={name} age={age} />
      <Footer />
    </>
  )
}
```

It now compiles successfully, and the DOM generated by React no longer contains the extra div-element.

## **b.JavaScript**

## Variables

```javascript
const x = 1
let y = 5

console.log(x, y)   // 1, 5 are printed
y += 10
console.log(x, y)   // 1, 15 are printed
y = 'sometext'
console.log(x, y)   // 1, sometext are printed
x = 4               // causes an error
```

const does not actually define a variable but a constant for which the value can no longer be changed. On the other hand let defines a normal variable.

It is also possible to define variables in JavaScript using the keyword var. var was, for a long time, the only way to define variables. const and let were only recently added in version ES6.

## Arrays

```javascript
const t = [1, -1, 3]

t.push(5)

console.log(t.length) // 4 is printed
console.log(t[1])     // -1 is printed

t.forEach(value => {
  console.log(value)  // numbers 1, -1, 3, 5 are printed, each to own line
}) 
```

Notable in this example is the fact that the contents of the array can be modified even though it is defined as a const. Because the array is an object, the variable always points to the same object. However, the content of the array changes as new items are added to it.

In React code, it is preferable to use the method concat, which does not add the item to the array, but creates a new array in which the content of the old array and the new item are both included.

```javascript
const t = [1, -1, 3]

const t2 = t.concat(5)

console.log(t)  // [1, -1, 3] is printed
console.log(t2) // [1, -1, 3, 5] is printed
```

The method call `t.concat(5)` does not add a new item to the old array but returns a new array which, besides containing the items of the old array, also contains the new item.

There are plenty of useful methods defined for arrays. Let's look at a short example of using the map method.

```javascript
const t = [1, 2, 3]

const m1 = t.map(value => value * 2)
console.log(m1)   // [2, 4, 6] is printed
```

```javascript
const m2 = t.map(value => '<li>' + value + '</li>')
console.log(m2)  
// [ '<li>1</li>', '<li>2</li>', '<li>3</li>' ] is printed
```

Individual items of an array are easy to assign to variables with the help of the destructuring assignment.

```javascript
const t = [1, 2, 3, 4, 5]

const [first, second, ...rest] = t

console.log(first, second)  // 1, 2 is printed
console.log(rest)          // [3, 4, 5] is printed
```

Thanks to the assignment, the variables `first` and `second` will receive the first two integers of the array as their values. The remaining integers are "collected" into an array of their own which is then assigned to the variable `rest`.

## Objects

There are a few different ways of defining objects in JavaScript. One very common method is using object literals, which happens by listing its properties within braces:

```javascript
const object1 = {
  name: 'Arto Hellas',
  age: 35,
  education: 'PhD',
}

const object2 = {
  name: 'Full Stack web application development',
  level: 'intermediate studies',
  size: 5,
}

const object3 = {
  name: {
    first: 'Dan',
    last: 'Abramov',
  },
  grades: [2, 3, 5, 3],
  department: 'Stanford University',
}
```

The properties of an object are referenced by using the "dot" notation, or by using brackets:

```javascript
console.log(object1.name)         // Arto Hellas is printed
const fieldName = 'age' 
console.log(object1[fieldName])    // 35 is printed
```

```javascript
object1.address = 'Helsinki'
object1['secret number'] = 12341
```

The latter of the additions has to be done by using brackets, because when using dot notation, secret number is not a valid property name because of the space character.

## Functions

The arrow function feature was added to JavaScript only a couple of years ago, with version ES6. Prior to this the only way to define functions was by using the keyword `function`.

## JavaScript materials
* [Mozilla's JavaScript Guide](https://developer.mozilla.org/en-US/docs/Web/JavaScript)
* [A re-introduction to JavaScript (JS tutorial)](https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript)
* [You-Dont-Know-JS](https://github.com/getify/You-Dont-Know-JS)
* [javascript.info](https://javascript.info/)

## **c. Component state, event handlers**

## Stateful component

imports the useState function:

```javascript
import React, { useState } from 'react'
```
The function body that defines the component begins with the function call:

```javascript
const [ counter, setCounter ] = useState(0)
```

The ```counter``` variable is assigned the initial value of state which is zero. The variable ```setCounter``` is assigned to a function that will be used to modify the state.

Every time the ```setCounter``` modifies the state it causes the component to re-render.

## Event handling

Button elements support so-called mouse events, of which click is the most common event.

```javascript
const App = () => {

  const handleClick = () => {
    console.log('clicked')
  }

  return (
    <div>
      <button onClick={handleClick}>
        plus
      </button>
    </div>
  )
}
```

The event handler function can also be defined directly in the value assignment of the onClick-attribute:

```javascript
const App = () => {

  return (
    <div>
      <button onClick={() => console.log('clicked')}>
        plus
      </button>
    </div>
  )
}
```

## Event handler is a function

⚠️ `<button onClick={setCounter(counter + 1)}>`

the event handler is actually a function call. In many situations this is ok, but not in this particular situation. In the beginning the value of the counter variable is 0. When React renders the component for the first time, it executes the function call setCounter(0+1), and changes the value of the component's state to 1. This will cause the component to be re-rendered, React will execute the setCounter function call again, and the state will change leading to another rerender...
Usually defining event handlers within JSX-templates is not a good idea. Here it's ok, because our event handlers are so simple.

## Passing state to child components

It's recommended to write React components that are small and reusable across the application and even across projects. 

> Often, several components need to reflect the same changing data. We recommend lifting the shared state up to their closest common ancestor.

Next, let's make a Button component for the buttons of our application.

```javascript
const Button = (props) => {
  return (
    <button onClick={props.onClick}>
      {props.text}
    </button>
  )
}
```

## Changes in state cause rerendering

Application starts ➡️ App is executed ➡️ useState hook  create the application state (setting an initial value of the variable counter). 

This component contains the Display component - which displays the counter's value, 0 - and three Button components. The buttons all have event handlers, which are used to change the state of the counter.

Buttons clicked ➡️ event handler executed ➡️ event handler changes the state of the App component with the setCounter function ➡️ Calling a function which changes the state causes the component to rerender.

So, if a user clicks the plus button, the button's event handler changes the value of counter to 1, and the App component is rerendered. This causes its subcomponents Display and Button to also be re-rendered. Display receives the new value of the counter, 1, as props. The Button components receive event handlers which can be used to change the state of the counter.

## Refactoring the components

The component only uses the `counter` field of its props. This means we can simplify the component by using destructuring

```javascript
const Display = ({ counter }) => {
  return (
    <div>{counter}</div>
  )
}
```

The function defining the component contains only the return statement, so we can define the function using the more compact form of arrow functions:

```javascript
const Display = ({ counter }) => <div>{counter}</div>
```

We can simplify the Button component as well.

## **d. A more complex state, debugging React apps**

## Complex state

```javascript
const [left, setLeft] = useState(0)
const [right, setRight] = useState(0)
```

We could implement the same functionality by saving the click count of both the left and right buttons into a single object:


```javascript
const [clicks, setClicks] = useState({
    left: 0, right: 0
})

const handleLeftClick = () => {
    const newClicks = { 
      left: clicks.left + 1, 
      right: clicks.right 
    }
    setClicks(newClicks)
}

const handleRightClick = () => {
    const newClicks = { 
        left: clicks.left, 
        right: clicks.right + 1 
    }
    setClicks(newClicks)
}
```
We can define the new state object a bit more neatly by using the *object spread* syntax:

```javascript
const handleLeftClick = () =>
  setClicks({ ...clicks, left: clicks.left + 1 })

const handleRightClick = () =>
  setClicks({ ...clicks, right: clicks.right + 1 })
```

In practice `{ ...clicks }` creates a new object that has **copies** of all of the properties of the clicks object.

⚠️ However, it is forbidden in React to mutate state directly, since it can result in unexpected side effects.

```javascript
const handleLeftClick = () => {
  clicks.left++
  setClicks(clicks)
}
```

Changing state has to always be done by setting the state to a new object.

## Handling arrays

```javascript
const App = () => {
  const [left, setLeft] = useState(0)
  const [right, setRight] = useState(0)
  const [allClicks, setAll] = useState([])

  const handleLeftClick = () => {
    setAll(allClicks.concat('L'))
    setLeft(left + 1)
  }

  const handleRightClick = () => {
    setAll(allClicks.concat('R'))
    setRight(right + 1)
  }

  return (
    <div>
      {left}
      <button onClick={handleLeftClick}>left</button>
      <button onClick={handleRightClick}>right</button>
      {right}
      <p>{allClicks.join(' ')}</p>
    </div>
  )
}
```

Adding the new item to the array is accomplished with the concat method, that does not mutate the existing array but rather returns a new copy of the array with the item added to it.

As mentioned previously, it's also possible in JavaScript to add items to an array with the push method.

```javascript
const handleLeftClick = () => {
  allClicks.push('L')
  setAll(allClicks)
  setLeft(left + 1)
}
```

The application would still appear to work. However, don't do this.

## Conditional rendering

```javascript
const History = (props) => {
  if (props.allClicks.length === 0) {
    return (
      <div>
        the app is used by pressing the buttons
      </div>
    )
  }
  return (
    <div>
      button press history: {props.allClicks.join(' ')}
    </div>
  )
}
```

## Old React

Before the addition of hooks, there was no way to add state to functional components. Components that required state had to be defined as class components, using the JavaScript class syntax.

## Debugging React applications
1. Keep the browser's developer console open at all times.
2. Old school, print-based debugging is always a good idea.
3. When you use console.log for debugging, don't combine objects in a Java-like fashion by using the plus operator. Instead of writing:

```javascript
console.log('props value is ' + props)
```

Separate the things you want to log to the console with a comma:

```javascript
console.log('props value is', props)
```

4. Logging to the console is by no means the only way of debugging our applications. You can pause the execution of your application code in the Chrome developer console's debugger, by writing the command `debugger` anywhere in your code.

5. It is highly recommended to add the React developer tools extension to Chrome. It adds a new `Components` tab to the developer tools. 

## Rules of Hooks

The useState function (as well as the useEffect function introduced later on in the course) must not be called from inside of a loop, a conditional expression, or any place that is not a function defining a component. This must be done to ensure that the hooks are always called in the same order, and if this isn't the case the application will behave erratically.

## Event Handling Revisited
⭐ Event handlers must always be a function or a reference to a function.

## Function that returns a function
(skip!) Another way to define an event handler is to use function that returns a function.

## Passing Event Handlers to Child Components
Using the component is simple, although we have to make sure that we use the correct attribute names when passing props to the component.

## Do Not Define Components Within Components
The application still appears to work, but **don't implement components like this!**

The biggest problems are due to the fact that React treats a component defined inside of another component as a new component in every render. This makes it impossible for React to optimize the component.

## Useful Reading
* [Official React documentation](https://reactjs.org/docs/hello-world.html)
* Some courses on [Egghead.io](https://egghead.io/) like [Start learning React](https://egghead.io/courses/react-with-class-components-fundamentals-4351f8bb) are of high quality, and recently updated [The Beginner's Guide to React](https://egghead.io/courses/the-beginner-s-guide-to-react) is also relatively good; both courses introduce concepts that will also be introduced later on in this course. NB The first one uses class components but the latter uses the new functional ones.